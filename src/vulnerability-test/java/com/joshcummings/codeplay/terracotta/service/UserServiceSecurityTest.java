package com.joshcummings.codeplay.terracotta.service;

import com.joshcummings.codeplay.terracotta.AbstractEmbeddedTomcatTest;
import com.joshcummings.codeplay.terracotta.model.User;
import org.testng.Assert;
import org.testng.annotations.Test;

/**
 * Security-focused test cases for UserService
 */
public class UserServiceSecurityTest extends AbstractEmbeddedTomcatTest {

    @Test(groups="sqlinjection")
    public void testRegisterWithSqlInjectionInUsername() {
        UserService userService = this.context.getBean(UserService.class);
        
        // SQL injection attempt in username
        String maliciousUsername = "admin' OR '1'='1";
        User testUser = new User("test_id", maliciousUsername, "password123", "Test Name", "test@example.com");
        
        // Should not throw exception with parameterized queries
        userService.addUser(testUser);
        
        // Verify user was added with the exact malicious username (proving no SQL injection occurred)
        User retrievedUser = userService.findByUsername(maliciousUsername);
        Assert.assertNotNull(retrievedUser, "User with malicious username should be retrievable");
        Assert.assertEquals(retrievedUser.getUsername(), maliciousUsername);
        
        // Clean up
        userService.removeUser(maliciousUsername);
    }
    
    @Test(groups="sqlinjection") 
    public void testMultipleSqlInjectionVectors() {
        UserService userService = this.context.getBean(UserService.class);
        
        // Test SQL injection in each field
        String sqlInjection = "' OR '1'='1";
        
        // Count users before test
        int initialCount = userService.count();
        
        // Try SQL injection in id field
        User userWithMaliciousId = new User(sqlInjection, "user1", "password", "name", "email@example.com");
        userService.addUser(userWithMaliciousId);
        
        // Try SQL injection in email field
        User userWithMaliciousEmail = new User("id2", "user2", "password", "name", sqlInjection);
        userService.addUser(userWithMaliciousEmail);
        
        // Try SQL injection in name field
        User userWithMaliciousName = new User("id3", "user3", "password", sqlInjection, "email3@example.com");
        userService.addUser(userWithMaliciousName);
        
        // Verify all 3 users were added properly (expected count increase of 3)
        int finalCount = userService.count();
        Assert.assertEquals(finalCount, initialCount + 3, "All 3 users should have been added successfully");
        
        // Clean up
        userService.removeUser("user1");
        userService.removeUser("user2");
        userService.removeUser("user3");
    }
    
    @Test(groups="sqlinjection")
    public void testUpdateUserWithSqlInjection() {
        UserService userService = this.context.getBean(UserService.class);
        
        // Create a normal user first
        User legitUser = new User("legit_id", "legituser", "password", "Original Name", "original@example.com");
        userService.addUser(legitUser);
        
        // Now try to update with SQL injection content
        String maliciousEmail = "hacked'; UPDATE users SET name='HACKED' WHERE username != 'legituser"; 
        legitUser.setEmail(maliciousEmail);
        
        try {
            // Update should work without causing injected SQL to execute
            userService.updateUser(legitUser);
            
            // Verify the user's email was updated to the literal string (SQL wasn't executed)
            User retrievedUser = userService.findByUsername("legituser");
            Assert.assertNotNull(retrievedUser, "User should still exist");
            Assert.assertEquals(retrievedUser.getEmail(), maliciousEmail, "Email should contain the literal malicious input");
        } finally {
            // Clean up
            userService.removeUser("legituser");
        }
    }
}