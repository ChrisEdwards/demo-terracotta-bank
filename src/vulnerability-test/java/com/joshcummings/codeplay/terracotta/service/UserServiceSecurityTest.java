package com.joshcummings.codeplay.terracotta.service;

import com.joshcummings.codeplay.terracotta.AbstractEmbeddedTomcatTest;
import com.joshcummings.codeplay.terracotta.model.User;
import org.junit.Assert;
import org.testng.annotations.AfterMethod;
import org.testng.annotations.BeforeMethod;
import org.testng.annotations.Test;

/**
 * Security tests for UserService that verify SQL injection mitigation.
 */
public class UserServiceSecurityTest extends AbstractEmbeddedTomcatTest {
    private UserService userService;
    private User testUser;
    
    @BeforeMethod(groups="sql-injection")
    public void setup() {
        userService = this.context.getBean(UserService.class);
        testUser = new User("sqlitest", "sqliuser", "password123", "Test User", "test@terracotta.com");
        userService.addUser(testUser);
    }
    
    @AfterMethod(groups="sql-injection")
    public void cleanup() {
        try {
            userService.removeUser("sqliuser");
        } catch (Exception e) {
            // Ignore cleanup errors
        }
    }
    
    /**
     * Test that verifies SQL injection is prevented in the login method.
     * This test attempts to use a SQL injection attack in the password field.
     */
    @Test(groups="sql-injection")
    public void testSqlInjectionInLoginPrevented() {
        // SQL injection attempt: using ' OR '1'='1 to bypass password check
        User user = userService.findByUsernameAndPassword("sqliuser", "' OR '1'='1");
        
        // If properly secured, the query should not return any user with this attack
        Assert.assertNull("SQL injection attack should not succeed", user);
        
        // Verify legitimate login still works
        User legitUser = userService.findByUsernameAndPassword("sqliuser", "password123");
        Assert.assertNotNull("Legitimate login should still work", legitUser);
        Assert.assertEquals("sqliuser", legitUser.getUsername());
    }
    
    /**
     * Test that verifies SQL injection using multiple statements is prevented.
     */
    @Test(groups="sql-injection")
    public void testMultiStatementSqlInjectionPrevented() {
        // SQL injection attempt: trying to add a malicious query with a semicolon
        User user = userService.findByUsernameAndPassword("sqliuser", "anything'; INSERT INTO users VALUES ('hacked','hacker','pwned','Hacker','hacker@evil.com'); --");
        
        // Should not succeed in authentication
        Assert.assertNull("SQL injection with multiple statements should not succeed", user);
        
        // Verify no rogue user was created
        User hackedUser = userService.findByUsername("hacker");
        Assert.assertNull("No rogue user should be created by the injection attack", hackedUser);
    }
}