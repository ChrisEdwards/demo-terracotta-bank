package com.joshcummings.codeplay.terracotta.service;

import com.joshcummings.codeplay.terracotta.AbstractEmbeddedTomcatTest;
import com.joshcummings.codeplay.terracotta.model.User;
import org.testng.annotations.Test;

/**
 * Tests to verify that the user service is protected against SQL injection attacks
 */
public class UserServiceSecurityTest extends AbstractEmbeddedTomcatTest {

    @Test(groups="sql-injection")
    public void testAddUserWithSqlInjectionAttemptInName() {
        UserService userService = this.context.getBean(UserService.class);
        
        // Create a user with an SQL injection attempt in the name field
        String maliciousName = "'); DROP TABLE users; --";
        String userId = "testInjection1";
        User user = new User(userId, "testuser1", "password123", maliciousName, "test@example.com");
        
        // This should not cause SQL errors or execute the malicious SQL
        userService.addUser(user);
        
        // Verify we can retrieve the user with the exact name we provided
        User retrievedUser = userService.findByUsername("testuser1");
        assert retrievedUser != null;
        assert maliciousName.equals(retrievedUser.getName());
    }

    @Test(groups="sql-injection")
    public void testAddUserWithSqlInjectionAttemptInEmail() {
        UserService userService = this.context.getBean(UserService.class);
        
        // Create a user with an SQL injection attempt in the email field
        String maliciousEmail = "test@example.com'); DELETE FROM users WHERE username != 'admin'; --";
        String userId = "testInjection2";
        User user = new User(userId, "testuser2", "password123", "Regular Name", maliciousEmail);
        
        // This should not cause SQL errors or execute the malicious SQL
        userService.addUser(user);
        
        // Verify we can retrieve the user with the exact email we provided
        User retrievedUser = userService.findByUsername("testuser2");
        assert retrievedUser != null;
        assert maliciousEmail.equals(retrievedUser.getEmail());
    }
    
    @Test(groups="sql-injection")
    public void testFindByUsernameWithSqlInjection() {
        UserService userService = this.context.getBean(UserService.class);
        
        // Add a regular user first
        User regularUser = new User("regular1", "regularuser", "password123", "Regular User", "regular@example.com");
        userService.addUser(regularUser);
        
        // Try to find with an SQL injection attempt in the username
        User result = userService.findByUsername("' OR '1'='1");
        
        // Should not find any users because our query is parameterized
        assert result == null;
    }
    
    @Test(groups="sql-injection")
    public void testServiceSupportTableNameValidation() {
        ServiceSupport serviceSupport = new ServiceSupport() {};
        
        try {
            // This should throw an IllegalArgumentException because it contains invalid characters
            serviceSupport.count("users; DROP TABLE users");
            assert false : "Should have thrown an exception for invalid table name";
        } catch (IllegalArgumentException e) {
            // Expected behavior
            assert e.getMessage().contains("Invalid table name");
        }
    }
}