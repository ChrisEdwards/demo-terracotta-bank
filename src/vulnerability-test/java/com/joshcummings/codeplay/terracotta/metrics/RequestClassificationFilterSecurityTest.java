/*
 * Copyright 2015-2023 Josh Cummings
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.joshcummings.codeplay.terracotta.metrics;

import org.springframework.mock.web.MockFilterChain;
import org.springframework.mock.web.MockHttpServletRequest;
import org.springframework.mock.web.MockHttpServletResponse;
import org.testng.annotations.BeforeMethod;
import org.testng.annotations.Test;

import java.io.IOException;
import java.util.Arrays;
import java.util.List;
import javax.servlet.ServletException;

import static org.testng.Assert.assertEquals;
import static org.testng.Assert.assertTrue;

public class RequestClassificationFilterSecurityTest {
    private RequestClassificationFilter filter;
    private MockHttpServletRequest request;
    private MockHttpServletResponse response;
    private MockFilterChain chain;

    @BeforeMethod
    public void setup() {
        filter = new RequestClassificationFilter();
        request = new MockHttpServletRequest();
        response = new MockHttpServletResponse();
        chain = new MockFilterChain();
    }

    @Test
    public void testValidParameterIsAllowed() throws ServletException, IOException {
        // Test with a valid classification parameter
        request.setParameter("c", "account");
        filter.doFilter(request, response, chain);
        
        assertEquals(response.getHeader("X-Terracotta-Classification"), "account",
                "Valid classification should be accepted");
    }

    @Test
    public void testInvalidParameterIsRejected() throws ServletException, IOException {
        // Test with an invalid classification that could be used for header injection
        request.setParameter("c", "malicious\r\nX-Custom-Header: Injected");
        filter.doFilter(request, response, chain);
        
        assertEquals(response.getHeader("X-Terracotta-Classification"), "unclassified", 
                "Invalid classification should be rejected");
        
        // Ensure the attempted header injection was not successful
        assertEquals(response.getHeader("X-Custom-Header"), null,
                "No injected header should be present");
    }

    @Test
    public void testNullParameterIsRejected() throws ServletException, IOException {
        // Test with no classification parameter provided
        filter.doFilter(request, response, chain);
        
        assertEquals(response.getHeader("X-Terracotta-Classification"), "unclassified",
                "Null classification should use default value");
    }
    
    @Test
    public void testHeaderInjectionAttempts() throws ServletException, IOException {
        // List of potential header injection attempts
        List<String> injectionAttempts = Arrays.asList(
            "malicious\r\nX-Injected-Header: value",
            "malicious\nX-Injected-Header: value",
            "malicious\r\n\tX-Injected-Header: value",
            "malicious\n\tX-Injected-Header: value",
            "malicious\rX-Injected-Header: value"
        );
        
        for (String attempt : injectionAttempts) {
            request.setParameter("c", attempt);
            filter.doFilter(request, response, chain);
            
            assertEquals(response.getHeader("X-Terracotta-Classification"), "unclassified",
                    "Header injection attempt should be rejected");
            
            assertEquals(response.getHeader("X-Injected-Header"), null,
                    "No injected header should be present");
        }
    }
}